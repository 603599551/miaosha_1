# 商品秒杀系统
## 高并发架构
## 1.框架：SpringBoot2.1.4, MyBatis2.0.1
## 2.数据库：MySQL5.1.21 ， Redis3.0.7（高速缓存）
## 4.消息队列： RabbitMQ(实现异步下单)
## 5.负载均衡： Nginx(未做)
## 6.系统压测： Jemter(模拟多线程的工具)
## 7.Tomcat集群(未做)


ID | Module | Problem 
:-: | :-: | :-: 
1 | 安全问题 | 如何保证用户密码的安全性？（两次MD5） |
2 | 安全问题 | 如何减少秒杀地址被攻击？（秒杀时动态获取地址） |
3 | 安全问题 | 如何防止机器人恶意秒杀？（数学公式验证码） | 
4 | 安全问题 | 如何做接口限流防刷？（限制用户在规定时间的访问次数）| 
5 | 登录功能 | 如何保持用户的登录状态？（单服务器、分布式session）| 
6 | 秒杀功能 | 数据表设计：为什么要有秒杀商品/订单/库存表？| 
7 | 秒杀功能 | 如何判断秒杀客户端是android / ios / pc ？| 
8 | 计算机网络 | 同样的网络，为什么内网ip会变化？（DHCP）| 
9 | 分布式一致性 | 在分布式下如何保证生成id的唯一性？（SnowFlake）|
10 | 秒杀功能 | 如何保证每个客户端的秒杀倒计时不出现偏差？（以服务器时间为准）|
11 | Springboot | SpringBoot事务管理？ |
12 | 代码优化 | SpringBoot自定义参数解析HandlerMethodArgumentResolver？|
13 | 代码优化 | 如何高效实现参数校验，少写重复代码？（JSR303）|
14 | Springboot | 注解@Configuration、@Bean详解？|
15 | Mybatis | 数据库操作CRUD的返回值？ |
16 | Mybatis | @SelectKey的参数解析？ |
17 | Springboot | vo类的成员变量是怎么映射到数据库表的字段上的？ |
18 | MySQL | 函数LAST_INSERT_ID()的使用方法？ |
19 | 性能优化 | 并发瓶颈、Redis性能瓶颈、横向扩展与纵向扩展？ |
20 | 性能优化 | 纵向扩展：数据库分库分表思路？（垂直/水平切分） |
21 | 性能优化 | 高并发下的缓存更新策略（Cache Aside Pattern） |
22 | Java | Java中的注解是如何工作的？ |
23 | 代码优化 | 同一时间段，不同接口能承受的访问次数不一样，如何写一个通用的限流方法以适应所有的情况？ |




<a href="./code-solve.md">问题详解</a>

## 9.功能模块(持续更新中)

### 9.1 登录功能
#### 9.1.1 用户密码两次MD5(已完成)
#### 9.1.2 使用JSR303校验参数(已完成)
#### 9.1.3 分布式session(已完成)


**_Q1：在并发量达到一定数量级时，是否需要采用Redis Cluster来存储session？
Q2：Redis Cluster的应用场景？****_**

### 9.2 秒杀功能

#### 9.2.1 数据库设计
商品表、订单表、秒杀商品表、秒杀订单表     

 **分布式事务？？？？？**

*****
#### SpringBoot 相关问题

tips ： Service只能调Service和对应的DAO，要调用其他的DAO必须通过其他的service调用


#### Redis 相关问题

**并发数达到一定时，为什么会使value为null？？**

### 9.3 压测功能（测QPS/TPS）
压测工具JMeter -- 自定义变量模拟多用户、多线程
Redis压测工具redis-benchmark


*****
**在高并发、分布式的情况下
电商库存模型？
如何防止同一用户重复秒杀？-----本项目是通过对数据库的秒杀订单的userId和goodsId加上唯一索引
如何防止超卖？-----本项目是由sql语句来限制，判断库存是否大于0再更新
预定库存？实际库存？
什么时候减库存？怎么减？
什么时候写入订单、秒杀订单？写入之后库存会发生什么变化？
付款后 库存又会发生什么变化？**

*****
**高并发、分布式下的支付问题？一致性？**

***** 

### 9.4 页面优化技术
1.页面缓存 + URL缓存 + 对象缓存 ： 减少对数据库的访问

如何实现页面缓存？
访问页面时，优先从Redis缓存中获取渲染过的html，若是没有就手动渲染模板得到渲染过的html并放到缓存中。
页面缓存是为了防止瞬间的访问量导致服务器压力太大，但是为了保证信息的实时性又不能缓存太长时间。

URL缓存与页面缓存的区别在于 GoodsCtrl的 toList()和toDetail() ，其实本质上都是页面缓存。

页面缓存的应用场景：短时间内变化不大的页面，如商品列表。
而实际项目中，商品列表一般是分页的，我们一般只缓存前一两页。

对象缓存的过期时间是永久，当对象的信息发生改变时要及时更新缓存，如用户信息对象。

**手动渲染？自动渲染？thymeleafViewResolver？**


2.页面静态化，前后端分离 ： 目前用的是thymeleaf，thymeleaf实际上是动态的；静态页面是纯html，通过js和ajax请求服务端获取数据来渲染页面
好处在于：可以将静态页面html缓存在客户端，这样客户端每次只需要从服务端获取动态部分的数据就行了，服务端只需要提供数据。

**静态页面一般放到/resources/static下，而templates包？？templates和static的区别？？**
**GET和POST方法的区别 详解**
**HTTP中的缓存控制开关Pragma 和 Cache-Control** https://blog.csdn.net/u012375924/article/details/82806617


3.静态资源（图片、js、css...）优化 
JS/CSS压缩（去掉多余的空格和字符），减少流量  -- **webpack**
组合多个JS/CSS文件的访问请求变成一个请求 -- **tengine web server**


4.内容分发网络CDN ：就近访问服务节点

页面优化总结：
用户发起请求时，浏览器通过页面静态化将页面缓存在浏览器端，请求到达服务端之前，我们可以部署一些CDN节点
**让请求先访问我们的CDN，通过CDN访问nginx缓存？？**，再到应用程序的页面缓存，对象缓存，最后访问到数据库
通过一层层的访问缓存，逐步削减到达数据库的请求数量，这样才能保证网站在高并发的情况下抗住压力。


### 9.5 接口优化
1.Redis预减库存以减少数据库的访问
2.内存标记以减少Redis的访问
3.请求先入队缓冲，异步下单，增强用户体验
**4.Nginx水平扩展--安装Nginx、反向代理、负载均衡**
**百万级并发 客户端->Nginx->Tomcat
千万级并发 客户端->LVS->Nginx->Tomcat**


详细优化流程：
+ 系统初始化，服务端把商品库存数量加载到Redis缓存中，map标记商品是否售罄
+ 服务端收到客户端的请求，先通过map判断商品是否售罄，未售罄的话进入下一步 **（减少对Redis的访问）**
+ Redis预减库存，若库存不足就直接返回“秒杀失败”，否则进入下一步 **（减少对数据库的访问）**
+ 查询Redis缓存中是否存在相应的秒杀订单，防止重复秒杀，没有的话进入下一步 **（减少对数据库的访问）**
+ 秒杀请求入队，服务端响应客户端“排队中”  **（同步下单 -> 异步下单）**
+ 秒杀请求出队，服务端判断数据库的库存是否大于0，没有的话进入下一步 **（防止超卖）**
+ 查询Redis缓存中是否存在相应的秒杀订单，防止重复秒杀，没有的话进入下一步 **（减少对数据库的访问）**
+ 服务端操作数据库：减库存->下订单->写入秒杀订单 ，整个过程成功的话会把秒杀订单放到Redis缓存中。
+ 若上一步的减库存失败，会在Redis缓存中标记该商品已售罄，并return false。
+ 客户端在收到响应“排队中”后，会轮询服务端的Redis缓存，直到秒杀成功或失败。（排队中0 成功orderId 失败-1）


#### 基于erlang的RabbitMQ 相关问题
queue类详解
AmqpTemplate类
注解@RabbitListener
**四种交换机exchange模式：direct、topic、fanout、headers详解**
RabbitMQ消息模型的核心思想（core idea）: 生产者会把消息发送给RabbitMQ的交换中心（Exchange），
Exchange的一侧是生产者，另一侧则是一个或多个队列，由Exchange决定一条消息的生命周期–发送给某些队列，或者直接丢弃掉。



**数据库的分库分表（阿里中间件：mycat）**

**强大的API文档工具swagger**



### 9.4 安全优化技术

+ 秒杀接口地址隐藏
+ 数学公式的验证码
+ 接口限流防刷

**项目哪里体现了多线程和高并发？**
首先我们采用了JMeter工具模拟多线程对系统进行了压测，因此不需要在代码中写“创建多线程”的代码。
其次我们在代码中没有对方法进行加锁等等，因为通过采用Redis预减库存的方式来防止超卖现象（保证数据一致性），不需要加锁并且不加锁的效率会更高。

**“多线程!=高并发”**
高并发（High Concurrency）是一种系统运行过程中遇到的一种“短时间内遇到大量操作请求”的情况，该情况的发生会导致系统在这段时间内执行大量操作，例如对资源的请求，数据库的操作等。
如果想要系统能够适应高并发状态，则需要从各个方面进行系统优化，包括，硬件、网络、系统架构、开发语言的选取、数据结构的运用、算法优化、数据库优化等……而多线程只是其中解决方法之一。

**我们的事务逻辑是 “减库存->下单->写入秒杀订单” ，正常逻辑是不是支付成功后才减库存？ 这个要去看看区别
库存涉及到几个 1.Redis预减库存（防止超卖，成功下单就可以锁定商品） 2.下单了但未支付的库存 3.成功支付后真正减去的库存**

**用户成功下单，但是未在规定期限内支付订单，订单自动取消，库存如何变化？**

