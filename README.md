# 商品秒杀系统
## 1.框架：SpringBoot(2.1.4) , MyBatis(2.0.1)
## 2.数据库：MySQL(5.1.21) ， Redis(3.0.7)
## 3.缓存持久化：Redis(3.0.7)
## 4.消息队列： RabbitMQ(待更新)
## 5.负载均衡： Nginx(待更新)
## 6.系统压测： Jemter(待更新)
## 7.Tomcat集群(待更新)

## 8.安全问题(持续更新中)
### 8.1 两次MD5：保证用户密码的安全
#### 8.1.1 第一次MD5
##### 用户端：PASSWORD1=MD5(密码明文+固定salt)
##### 第一次MD5是为了保证密码明文在网络传输过程中的安全
#### 8.1.2 第二次MD5
##### 服务端：PASSWORD2=MD5(PASSWORD1+随机salt)，然后将PASSWORD2和随机salt存入数据库
##### 第二次MD5是为了防止数据库被盗的情况下的密码安全。（因为通过彩虹表有可能反推出密码明文。）
##### 加盐后的密码经过哈希加密得到的哈希串与加盐前的哈希串完全不同，黑客用彩虹表得到的密码根本就不是真正的密码。
##### 即使黑客知道了“盐”的内容、加盐的位置，还需要对哈希加密函数H和规约函数R进行修改，彩虹表也需要重新生成，因此加盐能大大增加利用彩虹表攻击的难度。

## 9.功能模块(持续更新中)



### 9.1 登录功能
#### 9.1.1 用户密码两次MD5(已完成)
#### 9.1.2 使用JSR303校验参数(已完成)

#### 9.1.3 分布式session(已完成)

*****

##### 如何实现单服务器下的session？（保持用户的登录状态）
+ ①用户第一次登录成功，服务器为该用户创建一个session，并生成唯一的sessionID，然后就可以调用相关方法往session中增加内容了。
+ ②服务器将session存储在服务器的内存中，只把sessionID存到cookie中，并将cookie发送给客户端。
+ ③当客户端再次发送请求时，会把sessionID带上，服务器接收到请求后可以根据sessionID在内存中找到相应的session。

*****

##### 分布式Session共享解决方案

**问题原因：** 单服务器web应用中，session只会存储在该服务器中；当采用服务器集群时，若采用原先的session方案，会出现类似以下的问题：
用户的第一个请求发送到了服务器1，第二个请求发送到服务器2而找不到session，因此我们需要解决分布式session一致性的问题。

**方案1：session复制 （性能低，实现复杂，不常用）**
即 服务器之间同步session对象，使得每台服务器上都保存所有的session信息，使用session时，直接从本地获取。

**方案2：基于redis缓存的session共享**
即 用redis来存储所有的session信息，服务器每次读写session都访问redis。

_Q1：在并发量达到一定数量级时，是否需要采用Redis Cluster来存储session？
Q2：Redis Cluster的应用场景？****_

*****

##### 本项目的分布式session具体实现如下：
+ 登录成功，服务端给用户生成一个token来标识用户(token相当于sessionID)；
+ 服务端将token和用户信息存到redis缓存中，key-token，value-用户信息；
+ 服务端同时将token写到cookie中，传递给客户端，客户端在随后的请求中都会携带着token；
+ 服务端拿到token之后，就根据token取到对应的session信息.

**注意事项：** 客户端在登录成功后，每次发送请求都带着token，服务器要验证token来保持客户端的登录状态，并更新cookie和session的有效期。

#### 9.1.4 登录流程总结
参数格式校验->验证账号密码是否正确->登录成功









### 9.2 秒杀功能

#### 9.2.1 数据库设计
商品表、订单表、秒杀商品表、秒杀订单表     
*****

为什么要有秒杀商品表？
商城会经常搞活动，比如秒杀、大促、包邮等等。
如果没有秒杀商品表，每做一次活动就需要在商品表中添加字段来标识一下秒杀商品，在库存表标识可秒杀的库存，另外还要记录秒杀时间
时间长了，商品表、库存表等等会越来越难以维护。
商品表会非常不稳定，需要不停的修改，一修改之后可能导致所有的老代码都要做改动
而商品表应该要保持稳定，记录商品的基本信息 

*****

秒杀订单表单独维护秒杀订单，那么订单表就不需要加字段来标识了。

*****

实际在数据库中，价格不会存小数，都会存整数，代表 “分”

*****







同样的网络，为什么内网ip会变化？？？
由于IP地址资源有限，宽带接入运营商不能做到给每个用户都能分配一个固定的IP地址（所谓固定IP就是即使在你不上网的时候，别人也不能用这个IP地址，这个资源一直被你所独占），
所以要采用（动态主机配置协议）DHCP方式对局域网客户机进行临时的地址分配。（每次上网分配的IP地址可能会不一样，这跟当时IP地址资源有关。）
即 由DHCP服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。

*****

vo是怎么映射到数据库表的？？？
通过application.properties配置的参数mybatis.configuration.map-underscore-to-camel-case可以让mybatis自动将SQL中查出来的带下划线的字段，转换为驼峰标志，再去匹配类中的属性。

*****

分布式id生成算法SnowFlake：生成id的结果是一个64位大小的整数
https://segmentfault.com/a/1190000011282426?utm_source=tag-newest
本项目是直接使用UUID/ID自增，要进行改造！！！

*****
##### 秒杀倒计时 https://www.jb51.net/article/72305.htm
本项目现在实现的“秒杀倒计时”是以客户端的时间为准，后期要做如下改动：
倒计时要满足2个条件：
+ 以服务器时间为准；
+ 要考虑网络传输的耗时

记录以下3个时间戳：
+ client_request : 客户端向服务器发送请求的时间戳；
+ client_start : 客户端接收到服务器返回的时间戳并开始计时的时间戳；
+ server_response : 服务器响应客户端请求的时间戳；

要计算2个参数：
+ 网络传输的耗时 = |client_start - client_request| 
+ 时间偏差 = |client_start - server_response| - 网络传输的耗时

那么客户端可秒杀的时间要满足1个不等式： 
本地时间 + 时间偏差 + 网络传输的耗时 < 秒杀截止时间 即 本地时间 + |client_start - server_response| < 秒杀截止时间

实现思路：
+ 当用户第一次浏览页面时，客户端首先获取服务器的当前时间
+ 客户端的新时间以服务器时间为初始值，每隔一秒累加一秒并生成新的时间
+ 客户端的倒计时 = 服务器秒杀截止时间 - 服务器当前时间 - 网络传输耗时
https://www.jb51.net/article/72305.htm

*****
秒杀的渠道：android / ios / pc ? 如何判断??
前端js通过判断浏览器navigator的userAgent就可以判断客户端类型。

*****
在高并发、分布式的情况下
电商库存模型？
如何限制重复秒杀？
如何防止超卖？
预定库存？实际库存？
什么时候减库存？怎么减？
什么时候写入订单、秒杀订单？写入之后库存会发生什么变化？
付款后 库存又会发生什么变化？

*****
高并发、分布式下的支付问题？一致性？



*****
#### SpringBoot 相关问题
SpringBoot事务管理：编程式、声明式（其中包括@Transactional）。
参考：https://blog.csdn.net/nextyu/article/details/78669997

*****
#### Mybatis 相关问题
数据库操作的返回值
insert操作，返回值是插入成功的行数，但注解配置@SelectKey后，可以将新插入行的id映射到domain中相应的属性。
update/delete：返回值是更新或删除的行数；无需指明resultClass；但如果有约束异常而删除失败，只能去捕捉异常。
queryForObject：返回的是一个实例对象或null；需要包含<select>语句，并且指明resultMap；
queryForList：返回的是实例对象的列表；需要包含<select>语句，并且指明resultMap；


@SelectKey的参数解析
+ keyColumn -- 数据库的列  ； 
+ keyProperty -- 指定返回的列映射到domain中的哪个属性 ；
+ resultType -- 返回值的类型 ；
+ before -- SelectKey语句的执行是否在insert语句之前 ； 
+ statement -- 要运行的SQL语句

#### MYSQL 相关问题
MYSQL的函数LAST_INSERT_ID()：若插入一条数据，得到刚INSERT的行的主键值；若一条INSERT语句插入多行，只会返回插入的第一行数据时产生的值。 
为什么LAST_INSERT_ID()只适用于自增主键？
MYSQL官方手册说明的两种使用方法：
1.LAST_INSERT_ID()不带参数，与AUTO_INCREMENT属性一起使用，插入新记录时，返回该自增字段的值。
2.LAST_INSERT_ID(value+1)带参数，返回的是表达式“value+1”的值。


### 9.3 压测功能（测QPS/TPS）
压测工具JMeter -- 自定义变量模拟多用户、多线程

Redis压测工具redis-benchmark

SpringBoot打war包然后放到tomcat下运行(暂时不做)



